/*
  Utility Library.
  Common functions used by several commands.

  TODO:

*/

'use strict'

const fs = require('fs')
const { Avalanche, BinTools, BN } = require('avalanche')
const { KeyChain } = require('avalanche/dist/apis/evm')
const avm = require('avalanche/dist/apis/avm')
const HDKey = require('hdkey')
const bip39 = require('bip39')

// Inspect utility used for debugging.
const util = require('util')
util.inspect.defaultOptions = {
  showHidden: true,
  colors: true,
  depth: 1
}

const globalConfig = require('../config')

class AppUtils {
  constructor (config) {
    // this.ava = new Avalanche(globalConfig.AVAX_IP, parseInt(globalConfig.AVAX_PORT))
    this.ava = new Avalanche('api.avax.network', 443, 'https')
    this.localConfig = globalConfig
    this.KeyChain = KeyChain
    this.HDKey = HDKey
    this.bip39 = bip39

    this.bintools = BinTools.getInstance()
    this.avm = avm
    this.xchain = this.ava.XChain()
    this.BN = BN
  }

  // Open a wallet by file name.
  openWallet (filename) {
    try {
      // Delete the cached copy of the wallet. This allows testing of list-wallets.
      delete require.cache[require.resolve(filename)]

      const walletInfo = require(filename)
      return walletInfo
    } catch (err) {
      throw new Error(`Could not open ${filename}`)
    }
  }

  // Save a wallet to a file.
  saveWallet (filename, walletData) {
    return new Promise((resolve, reject) => {
      fs.writeFile(filename, JSON.stringify(walletData, null, 2), function (
        err
      ) {
        if (err) {
          return reject(console.error(err))
        }
        // const name = path.parse(filename).name
        // console.log(`${name}.json written successfully.`)
        return resolve()
      })
    })
  }

  // Broadcasts the transaction to the avalanche network.
  // Expects a avm.Txgenerated by sendAvax(). Returns a TXID
  // or throws an error.
  async broadcastAvaxTx (Tx) {
    try {
      const txid = await this.xchain.issueTx(Tx)

      return txid
    } catch (err) {
      console.log('Error in util.js/broadcastAvaxTx()')
      throw err
    }
  }

  // Generates a link to the block explorer on the command line terminal.
  displayAvaxTxid (txid) {
    console.log(' ')
    console.log(`TXID: ${txid}`)

    console.log('Check transaction status on the block explorer:')
    console.log(`https://explorer.avax.network/tx/${txid}`)
  }

  sleep (ms) {
    return new Promise(resolve => setTimeout(resolve, ms))
  }

  // Generates an array of HD addresses.
  // Address are generated from index to limit.
  // e.g. generateAddress(walletInfo, 20, 10)
  // will generate a 20-element array of addresses from index 20 to 29
  generateAvalancheAddress (walletInfo, index, limit) {
    if (!walletInfo.mnemonic) throw new Error('mnemonic is undefined!')

    // parse them into a seed
    const seed = this.bip39.mnemonicToSeedSync(walletInfo.mnemonic)
    // create the master node and derive it
    const masterHdKey = this.HDKey.fromMasterSeed(seed)

    // Get the node information
    const xkeyChain = new KeyChain(this.ava.getHRP(), 'X')

    // Populate the keychain
    for (let i = index; i < index + limit; i++) {
      const derivationPath = `${this.localConfig.AVA_ACCOUNT_PATH}/0/${i}`
      // derive an external change address HDNode
      const change = masterHdKey.derive(derivationPath)
      xkeyChain.importKey(change.privateKey)
    }
    return xkeyChain.getAddressStrings()
  }

  // Generate a change address from a Mnemonic of a private key.
  avalancheChangeAddress (walletInfo, index) {
    try {
      if (!index && index !== 0) {
        throw new Error('index must be a non-negative integer.')
      }

      // parse them into a seed
      const seed = this.bip39.mnemonicToSeedSync(walletInfo.mnemonic)
      // create the master node and derive it
      const masterHdKey = this.HDKey.fromMasterSeed(seed)
      const xkeyChain = new KeyChain(this.ava.getHRP(), 'X')
      const derivationPath = `${this.localConfig.AVA_ACCOUNT_PATH}/0/${index}`
      const change = masterHdKey.derive(derivationPath)
      xkeyChain.importKey(change.privateKey)

      return xkeyChain
    } catch (err) {
      console.log('Error in util.js/changeAddrFromMnemonic()')
      throw err
    }
  }

  encodeUtxo (utxoJSON, address) {
    const amount = new this.BN(utxoJSON.amount)
    const addressBuffer = this.ava.XChain().parseAddress(address)

    const transferInput = new this.avm.SECPTransferInput(amount)
    transferInput.addSignatureIdx(0, addressBuffer)

    const utxoObject = new this.avm.TransferableInput(
      this.bintools.cb58Decode(utxoJSON.txid),
      Buffer.from(utxoJSON.outputIdx, 'hex'),
      this.bintools.cb58Decode(utxoJSON.assetID),
      transferInput
    )

    return utxoObject // TxInput
  }

  generateOutput (amount, address, assetID) {
    const tokenTransferOutput = new this.avm.SECPTransferOutput(amount, [
      address
    ])
    return new this.avm.TransferableOutput(assetID, tokenTransferOutput)
  }

  // Read a paritally signed transaction and convert it to a JSON object.
  readTx (hex) {
    const baseTx = new this.avm.BaseTx()
    const buffer = Buffer.from(hex, 'hex')
    baseTx.fromBuffer(buffer)

    const tx = {}

    tx.typeName = baseTx.getTypeName()

    const inputs = baseTx.getIns()
    tx.inputs = inputs.map(input => {
      const formated = {}
      formated.asset = this.bintools.cb58Encode(input.getAssetID())
      formated.amount = input
        .getInput()
        .getAmount()
        .toNumber()
      return formated
    })

    const outputs = baseTx.getOuts()
    tx.outputs = outputs.map(output => {
      const formated = {}
      formated.asset = this.bintools.cb58Encode(output.getAssetID())
      formated.amount = output
        .getOutput()
        .getAmount()
        .toNumber()
      formated.addresses = output
        .getOutput()
        .getAddresses()
        .map(this.ava.XChain().addressFromBuffer)
      return formated
    })

    console.log(JSON.stringify(tx, null, 2))
    return tx
  }
}

module.exports = AppUtils
